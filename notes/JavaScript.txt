Udemy Course
Title: JavaScript: Understanding the Weird Parts
Date: 4.8.2020
-----------------------------------------------------
+"Do not Imitate, UNDERSTAND"+
-----------------------------------------------------
Big WORD Alert:
1. Syntax Parsers - used for reading and understanding the code that is written, so that machine can understand it (parsing means dividing a large
entity into smaller entities for better understanding)
2. Lexical Environment - the rules of how code should be written and position of elements of code ( Example: after function there is a space 
then a name)
3. Execution Context - a wrapper to help manage the code that is running
4. Name/Value Pair - a name which maps to a unique value
5. object - a collection of name/value pairs (This is the simplest explanation of objects in JavaScript)
6. Hoisting - unique JavaScript behaviour 
7. "undefined" - value of variables that is later replaced by the real values of variables, never set the value of variable to undefined let the JavaScript 
Engine do it for you
8. Single Threaded - single command is executed at a time, JavaScript is a Single Threaded programming language, but it does not mean that browsers
are executing all other commands in a single thread manner. In JavaScript only one thing is happening at a time.
9. Function Invocation and Execution Stack- running a function ( calling a function ), execution stack is collection of stacks that represent the contexts
that are being executed.
10. Variable Environment - is the environment that is created for variables in a specific execution context
11. Scope Chain - the relationship between functions, their lexical environments, relationship established as parent - child relationship
12. Asynchronous - more than one at a time 
13. "let" - variable type
----------------- END OF SECTION 2 ----------------------------
14. Dynamic Typing - In JavaScript user does not specify what type a certain variable is ( this is common in other programming languages ) where you 
specify that variable is of type integer then the programming language engine is expecting a specific value to be inserted in that variable. In JavaScript
type is not specified, the type of variables are "var" which basically means "variable", and when engine goes through different phases of creation and
execution it will understand and set a certain type to a variable
15. Primitive Types in JavaScript (+)
16. Operators 
17. Operator Precedence - "Pravo prvenstva" at operators, which operator will be executed first, is it * or + ...
18. Operator Associativity - happens when we have multiple operators with the same precedence, will they execute from left to right or opposite
19. Coercion - converting a value from one type to another
20. Comparison Operators 
21. Existence and Booleans - boolean values are able to tell if a certain variable has a value inside of it, every variable with a value that is not: 0,
undefined, null, " "... is equal to true.

--------------------------------------------------------------------------------
4. Name/Value Pair Example:
- Example would be a basic variable
- name = "Orhan"

+++++++++++++++++++++

5. object Example:
- As it is defined, in the simplest form possible in JavaScript - object is a collection of name/value pairs
- Example:
Address = {
	street:"Gigim Street",
	number: 9
	apartment:{
		floor:2,
		position :"Middle",
		number:301
	}
}

++++++++++++++++++++++

3. Execution Context:
-Great article on execution context - http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/

Global Execution Context:
- "Global" -> in JavaScript means: "Not inside a function".
- Is the base execution context in any JavaScript Code that is always created by the JavaScript Engine, it does not matter if there is no code in the
.js file the global execution context will always be created.
- Global Execution Context has 2 main things that are created with it and that is Global Objects and "this" (which is a global variable).
- When something is "global" it means that is always and everywhere accessible in your code.
- Global Object created in any kind of browser when running the JavaScript code is called "window" and it is equal to "this" variable, which means 
that "window" and "this" have equal values and they are the same in the Global Environment of browsers.
- It is important to note that every tab is a new "window" that creates its own Global Environment.

-If variables and functions are created on a global level they will be attached to the global object - "window" or "this" (because they are the same)


+++++++++++++++++++++++
2 Phases that the code goes through: 

Creation Phase: Elements of the Execution Context - https://prnt.sc/tx52pe
Execution Phase: Elements of the Execution Context - https://prnt.sc/tx5b3u

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

6.  Hoisting
- Every JavaScript file when it is run is divided into phases.
- First phase is the "Creation" phase where the "hoisting" behaviour happens.
- In the Creation phase syntax parser goes through the code line by line and creates all the variable and functions in the memory, allocating memory
space for them.
- Every variable created in this phase will have an "undefined" value assigned to them while every function will store its own values in the memory
- In other phases the values of variables are added to the memory
- An example of this can be seen here: https://prnt.sc/tv2zhk

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

9. To Invoke a Function and Execution Stack
- Invocation of a function is running the contents of a function.
- It is basically creating an Execution Context that the JavaScript engine will enter and execute a code inside of it.

- Invoking a function is easy, at the first hierarchical level outside of the function just call the name of the function with "()"
-Example:

function example(){
	console.log("It is working");
} 

example();

- "example();" is the Invocation of a function.

-At the initial phase of running a code, Creation Phase will begin on the Global Level, which means that only global variable and function will be allocated
and run.
-To access other functions and execute them we need to Invoke them on the global level, and move further down the path.
- This process of invoking and adding the functions to the execution is called "Execution Stack", every function added to the Execution Stack is added
at the top and it is immediately executed line by line after the top function is finished and it didnt invoke to a new function it will "pop off" the
execution stack and move to the function below it.

- Image of the Execution Stack and Invoking Functions - https://prnt.sc/tz02t6
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

10. Variable Environment

- Every execution context ( it does not matter if it is global or functional execution context ) can be looked at as the independent environment that is
created
- What this means is that every context has its own Variable Environment.
- Every variable environment of specific execution context is independent of one another, which means that variable with same names can be created in
different variable environments and they wont influence one another.

-The Example of multiple Variable Environments with same variable names can be found here: https://prnt.sc/u012rx
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

11. Scope Chain

- Scope determines the accessibility (visibility) of variables.
- Scope Chain represents the relationship between the variables from the perspective of a scope.

- Example: https://prnt.sc/u01jpz
- In the example; function b() is trying to console.log the value of "myVar" variable but it did not declare the value of this variable, what will happen
is determined by the scope chain.
- Function b() because it does not know what is the value of variable will try to find it outside of its execution context ( in the outer environment ) and
scope chain will tell it that outside of this function is global execution context and will look for the value of "myVar" there, if function b() was inside 
the function a() it would then look at the value of "myVar" variable there, if a() also does not know the value of "myVar" it will go outside of a(), this
will proceed until the value of "myVar" is found through the Scope Chain or until the end is reached and the value is not declared.

-Example of a code when function b() is one level below the global level - https://prnt.sc/u01lfm (meaning that it will look for answer in global context)
- Example of a code when function b() is inside function a() - https://prnt.sc/u01mae

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
12. Asynchronous

- We have already established that JavaScript is a synchronous / single threaded programming language.
- Meaning that it is able to execute lines of code or statements one by one.
- But in a way that JavaScript Engine behaves in a browser when it is executed it creates an imagination that it is a Asynchronous language.

- When JavaScript is executed the first thing that happens is that the whole JavaScript Code is being executed, everything that is part of the Execution
Stack will be executed until the Execution Stack is empty.
- But, while the execution stack is being executed something called the Event Queue is being filled with different events that are happening on the
page, such as "Click" event (Someone pressing something on the page).
- Only when the whole Execution Stack is empty only then will the functions assigned to handle these events will be loaded into the stack to resolve 
events.
- Furthermore, resolving events is also a Synchronous process only a single event handler function will be loaded on the execution stack and only when
it "pops out" of the stack the other function is loaded that will be used to handle second event on event queue.

Examples : https://prnt.sc/u0gthg and https://prnt.sc/u0gtt3 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

13. "let" variable type
Great Information about "let" - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let

- "let" is a type of variable that is used in specific scenarios
- It is intialized in the same way as the "var"
- Example: let variable1 = 1;

- "let" variables are unique in a way that they are used 
-  "var" variables scope is defined in the function itself while the "let" variables change and they are unique for any block statement ({} statements, like
for loop, if statements and etc.)

Example: https://prnt.sc/u0gq3q and https://prnt.sc/u0gui9

----------------- END OF SECTION 2 ----------------------------
15. Primitive Types in JavaScript

-Primitive type is just the type of variable that is commonly set in other programming languages manually while in JavaScript primitive types are set
dynamically.
- There are 6 Primitive Types in JavaScript:
1. "Undefined" - is a value set to variables that represent lack of existence, meaning the variable has no value set to it
2. "Null" - similar to the "Undefined" value of variable, it represents that value is not set, but the difference is that "Null" should be set by the programmer
if he wants to and "Undefined" shouldn't 
3. "Boolean" - has only two values, true or false
4. "Number" - holds all values of number types, it is a floating number which means that it always has some decimals attached to it
5. "String" - a sequence of characters, words basically
6. "Symbol" - new type introduced in ES6 (Version of JavaScript)

++++++++++++++++++++++++++++++++++++++++++++
19. Coercion - converting a value from one type to another

- Because JavaScript is a dynamically allocated programming language, meaning that it has dynamic typing, coercion is one of the methods that it uses
when things become a bit messy.
- Operators are able to work with strings and numbers, but what happens when we use strings and numbers in the same equation. 
- Example of operators working with strings and numbers separately - https://prnt.sc/u2uzay

- Coercion happens when we use multiple different primitive types with a single operator.
- For an example adding 1 and 2 where 2 is a string, will result in something unexpected.
- The result can be seen here - https://prnt.sc/u2v2am
- The result of this operation is 12 because JavaScript Engine knows that 1 and 2 are of two different types and it is coercing 1 into string so they are
compatible with each other. 
- How will JavaScript coerce in different situations and what will switch into what type is something that is defined deep into the JavaScript Engine.
- Just be aware that it happens.
- When an unexpected result happens, following the path of execution (Execution Stack), scope of variable (Scope Chain) and understanding the 
coercion will help us decode what happened.

+++++++++++++++++++++++++++++++++++++++++++++
20. Comparison Operators 

- This is a very long and detailed topic
- It talks about comparisons in the JavaScript and how values are converted and compared so that comparing 1 and true will return that they are equal
- Also in JavaScript there exist "===" that is used in block statements that looks for the absolute equal, which means that it will not convert any values
that values have to be equal to one another no matter what without any conversion. 
- Example: https://prnt.sc/u3hwvs
- Documentation MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness