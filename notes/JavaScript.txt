Udemy Course
Title: JavaScript: Understanding the Weird Parts
Date: 4.8.2020
-----------------------------------------------------
+"Do not Imitate, UNDERSTAND"+
-----------------------------------------------------
Big WORD Alert:
1. Syntax Parsers - used for reading and understanding the code that is written, so that machine can understand it (parsing means dividing a large
entity into smaller entities for better understanding)
2. Lexical Environment - the rules of how code should be written and position of elements of code ( Example: after function there is a space 
then a name)
3. Execution Context - a wrapper to help manage the code that is running
4. Name/Value Pair - a name which maps to a unique value
5. object - a collection of name/value pairs (This is the simplest explanation of objects in JavaScript)
6. Hoisting - unique JavaScript behaviour 
7. "undefined" - value of variables that is later replaced by the real values of variables, never set the value of variable to undefined let the JavaScript 
Engine do it for you
8. Single Threaded - single command is executed at a time, JavaScript is a Single Threaded programming language, but it does not mean that browsers
are executing all other commands in a single thread manner. In JavaScript only one thing is happening at a time.
9. Function Invocation and Execution Stack- running a function ( calling a function ), execution stack is collection of stacks that represent the contexts
that are being executed.
10. Variable Environment - is the environment that is created for a variables in a specific execution context
11. Scope Chain - the relationship between functions, their lexical environments, relationship established as parent - child relationship

--------------------------------------------------------------------------------
4. Name/Value Pair Example:
- Example would be a basic variable
- name = "Orhan"

+++++++++++++++++++++

5. object Example:
- As it is defined, in the simplest form possible in JavaScript - object is a collection of name/value pairs
- Example:
Address = {
	street:"Gigim Street",
	number: 9
	apartment:{
		floor:2,
		position :"Middle",
		number:301
	}
}

++++++++++++++++++++++

3. Execution Context:
-Great article on execution context - http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/

Global Execution Context:
- "Global" -> in JavaScript means: "Not inside a function".
- Is the base execution context in any JavaScript Code that is always created by the JavaScript Engine, it does not matter if there is no code in the
.js file the global execution context will always be created.
- Global Execution Context has 2 main things that are created with it and that is Global Objects and "this" (which is a global variable).
- When something is "global" it means that is always and everywhere accessible in your code.
- Global Object created in any kind of browser when running the JavaScript code is called "window" and it is equal to "this" variable, which means 
that "window" and "this" have equal values and they are the same in the Global Environment of browsers.
- It is important to note that every tab is a new "window" that creates its own Global Environment.

-If variables and functions are created on a global level they will be attached to the global object - "window" or "this" (because they are the same)


+++++++++++++++++++++++
2 Phases that the code goes through: 

Creation Phase: Elements of the Execution Context - https://prnt.sc/tx52pe
Execution Phase: Elements of the Execution Context - https://prnt.sc/tx5b3u

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

6.  Hoisting
- Every JavaScript file when it is run is divided into phases.
- First phase is the "Creation" phase where the "hoisting" behaviour happens.
- In the Creation phase syntax parser goes through the code line by line and creates all the variable and functions in the memory, allocating memory
space for them.
- Every variable created in this phase will have an "undefined" value assigned to them while every function will store its own values in the memory
- In other phases the values of variables are added to the memory
- An example of this can be seen here: https://prnt.sc/tv2zhk

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

9. To Invoke a Function and Execution Stack
- Invocation of a function is running the contents of a function.
- It is basically creating an Execution Context that the JavaScript engine will enter and execute a code inside of it.

- Invoking a function is easy, at the first hierarchical level outside of the function just call the name of the function with "()"
-Example:

function example(){
	console.log("It is working");
} 

example();

- "example();" is the Invocation of a function.

-At the initial phase of running a code, Creation Phase will begin on the Global Level, which means that only global variable and function will be allocated
and run.
-To access other functions and execute them we need to Invoke them on the global level, and move further down the path.
- This process of invoking and adding the functions to the execution is called "Execution Stack", every function added to the Execution Stack is added
at the top and it is immediately executed line by line after the top function is finished and it didnt invoke to a new function it will "pop off" the
execution stack and move to the function below it.

- Image of the Execution Stack and Invoking Functions - https://prnt.sc/tz02t6
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

10. Variable Environment

- Every execution context ( it does not matter if it is global or functional execution context ) can be looked at as the independent environment that is
created
- What this means is that every context has its own Variable Environment.
- Every variable environment of specific execution context is independent of one another, which means that variable with same names can be created in
different variable environments and they wont influence one another.

-The Example of multiple Variable Environments with same variable names can be found here: https://prnt.sc/u012rx
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

11. Scope Chain

- Scope determines the accessibility (visibility) of variables.
- Scope Chain represents the relationship between the variables from the perspective of a scope.

- Example: https://prnt.sc/u01jpz
- In the example; function b() is trying to console.log the value of "myVar" variable but it did not declare the value of this variable, what will happen
is determined by the scope chain.
- Function b() because it does not know what is the value of variable will try to find it outside of its execution context ( in the outer environment ) and
scope chain will tell it that outside of this function is global execution context and will look for the value of "myVar" there, if function b() was inside 
the function a() it would then look at the value of "myVar" variable there, if a() also does not know the value of "myVar" it will go outside of a(), this
will proceed until the value of "myVar" is found through the Scope Chain or until the end is reached and the value is not declared.

-Example of a code when function b() is one level below the global level - https://prnt.sc/u01lfm (meaning that it will look for answer in global context)
- Example of a code when function b() is inside function a() - https://prnt.sc/u01mae